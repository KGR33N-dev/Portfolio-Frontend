---
import type { Language } from '../../types/language';
import { blogTranslations } from '../../i18n/pages/blog';
import { API_URLS } from '../../config/api';

interface Props {
  postId: number;
  lang: Language;
}

const { postId, lang } = Astro.props;

// Access translations
const t = blogTranslations[lang as unknown as 'en' | 'pl'];

// Get API URLs for client-side use - we need to build templates since functions can't be serialized
const apiUrls = {
  getPostComments: API_URLS.getPostComments(postId),
  createPostComment: API_URLS.createPostComment(postId),
  // Template URLs for dynamic comment IDs (replace {id} with actual ID)
  likeCommentTemplate: API_URLS.likeComment(999999).replace('999999', '{id}'),
  updateCommentTemplate: API_URLS.updatePostComment(999999).replace('999999', '{id}'),
  deleteCommentTemplate: API_URLS.deletePostComment(999999).replace('999999', '{id}')
};
---

<script define:vars={{ 
  postId, 
  lang,
  translations: t,
  apiUrls,
  isDev: import.meta.env.DEV
}}>
  let currentUser = null;
  let isInitialized = false;
  let isLoadingComments = false;
  let initTimer = null;
  
  // Debounced likes system for better UX and performance
  class DebouncedLikes {
    constructor() {
      this.debounceTimers = new Map();
      this.pendingStates = new Map(); // Track pending states for each comment
    }

    async debouncedToggleLike(commentId, action, delay = 500) {
      console.log(`🎯 DebouncedLikes.debouncedToggleLike: commentId=${commentId}, action=${action}`);
      
      // Clear any existing timer for this comment
      if (this.debounceTimers.has(commentId)) {
        clearTimeout(this.debounceTimers.get(commentId));
        console.log(`⏰ Cleared existing timer for comment ${commentId}`);
      }

      // Get current UI state
      const likeBtn = document.querySelector(`[data-action="like"][data-id="${commentId}"]`);
      const dislikeBtn = document.querySelector(`[data-action="dislike"][data-id="${commentId}"]`);
      
      console.log(`🔍 Found buttons:`, { likeBtn: !!likeBtn, dislikeBtn: !!dislikeBtn });
      
      if (!likeBtn || !dislikeBtn) {
        console.error(`❌ Buttons not found for comment ${commentId}`);
        return;
      }

      const currentState = likeBtn.dataset.currentState;
      const currentLikes = parseInt(likeBtn.querySelector('.like-count').textContent) || 0;
      const currentDislikes = parseInt(dislikeBtn.querySelector('.dislike-count').textContent) || 0;
      
      console.log(`📊 Current state: ${currentState}, likes: ${currentLikes}, dislikes: ${currentDislikes}`);

      // Calculate optimistic state
      let newLikeState = null;
      let newLikes = currentLikes;
      let newDislikes = currentDislikes;

      if (action === 'like') {
        if (currentState === 'true') {
          // User already liked, remove like
          newLikeState = null;
          newLikes = Math.max(0, currentLikes - 1);
          console.log(`👎 Removing like: ${currentLikes} -> ${newLikes}`);
        } else {
          // User didn't like or disliked, add like
          newLikeState = true;
          newLikes = currentLikes + 1;
          if (currentState === 'false') {
            newDislikes = Math.max(0, currentDislikes - 1);
            console.log(`👍 Adding like, removing dislike: likes ${currentLikes} -> ${newLikes}, dislikes ${currentDislikes} -> ${newDislikes}`);
          } else {
            console.log(`👍 Adding like: ${currentLikes} -> ${newLikes}`);
          }
        }
      } else if (action === 'dislike') {
        if (currentState === 'false') {
          // User already disliked, remove dislike
          newLikeState = null;
          newDislikes = Math.max(0, currentDislikes - 1);
          console.log(`👍 Removing dislike: ${currentDislikes} -> ${newDislikes}`);
        } else {
          // User didn't dislike or liked, add dislike
          newLikeState = false;
          newDislikes = currentDislikes + 1;
          if (currentState === 'true') {
            newLikes = Math.max(0, currentLikes - 1);
            console.log(`👎 Adding dislike, removing like: dislikes ${currentDislikes} -> ${newDislikes}, likes ${currentLikes} -> ${newLikes}`);
          } else {
            console.log(`👎 Adding dislike: ${currentDislikes} -> ${newDislikes}`);
          }
        }
      }

      console.log(`🔄 New state will be: ${newLikeState}, likes: ${newLikes}, dislikes: ${newDislikes}`);

      // Immediate UI update (optimistic)
      this.updateUIImmediately(likeBtn, dislikeBtn, newLikeState, newLikes, newDislikes);
      
      // Store pending state
      this.pendingStates.set(commentId, {
        originalState: currentState,
        originalLikes: currentLikes,
        originalDislikes: currentDislikes,
        newState: newLikeState,
        likeBtn,
        dislikeBtn
      });

      // Set debounced server call
      const timer = setTimeout(async () => {
        try {
          console.log(`📡 Sending to server: comment ${commentId}, state ${newLikeState}`);
          await this.sendToServer(commentId, newLikeState);
          this.debounceTimers.delete(commentId);
          this.pendingStates.delete(commentId);
          console.log(`✅ ${action} sent to server for comment ${commentId}`);
        } catch (error) {
          console.error(`❌ Failed to send ${action} to server:`, error);
          this.revertUIChange(commentId);
        }
      }, delay);

      this.debounceTimers.set(commentId, timer);
      console.log(`⏱️ Timer set for comment ${commentId} with ${delay}ms delay`);
    }

    updateUIImmediately(likeBtn, dislikeBtn, likeState, likesCount, dislikesCount) {
      const likeCountEl = likeBtn.querySelector('.like-count');
      const dislikeCountEl = dislikeBtn.querySelector('.dislike-count');
      const likeSvg = likeBtn.querySelector('svg');
      const dislikeSvg = dislikeBtn.querySelector('svg');

      // Update counts
      likeCountEl.textContent = likesCount;
      dislikeCountEl.textContent = dislikesCount;

      // Update button states
      likeBtn.dataset.currentState = likeState;
      dislikeBtn.dataset.currentState = likeState;

      // Update like button appearance
      if (likeState === true) {
        likeBtn.className = 'like-btn flex items-center space-x-2 px-4 py-2.5 rounded-xl hover:bg-gray-100 dark:hover:bg-gray-700 transition-all duration-200 text-sm font-semibold border-2 text-blue-600 bg-blue-50 dark:bg-blue-900/30 border-blue-200 dark:border-blue-700';
        likeSvg.setAttribute('fill', 'currentColor');
      } else {
        likeBtn.className = 'like-btn flex items-center space-x-2 px-4 py-2.5 rounded-xl hover:bg-gray-100 dark:hover:bg-gray-700 transition-all duration-200 text-sm font-semibold border-2 text-gray-600 dark:text-gray-400 border-gray-200 dark:border-gray-600';
        likeSvg.setAttribute('fill', 'none');
      }

      // Update dislike button appearance
      if (likeState === false) {
        dislikeBtn.className = 'dislike-btn flex items-center space-x-2 px-4 py-2.5 rounded-xl hover:bg-gray-100 dark:hover:bg-gray-700 transition-all duration-200 text-sm font-semibold border-2 text-red-600 bg-red-50 dark:bg-red-900/30 border-red-200 dark:border-red-700';
        dislikeSvg.setAttribute('fill', 'currentColor');
      } else {
        dislikeBtn.className = 'dislike-btn flex items-center space-x-2 px-4 py-2.5 rounded-xl hover:bg-gray-100 dark:hover:bg-gray-700 transition-all duration-200 text-sm font-semibold border-2 text-gray-600 dark:text-gray-400 border-gray-200 dark:border-gray-600';
        dislikeSvg.setAttribute('fill', 'none');
      }
    }

    async sendToServer(commentId, likeState) {
      const token = localStorage.getItem('access_token');
      
      if (!token) {
        throw new Error('No authentication token');
      }

      const url = apiUrls.likeCommentTemplate.replace('{id}', commentId);
      
      // Zgodnie z dokumentacją API: is_like: boolean (true = like, false = dislike)
      // Jeśli likeState jest null, oznacza to usunięcie polubienia - nie wysyłamy żądania
      if (likeState === null) {
        // Dla usunięcia polubienia, wysyłamy przeciwny stan i potem ponownie ten sam
        // Ale lepiej będzie dodać dedykowany endpoint DELETE w przyszłości
        console.log('Removing like/dislike by toggling state');
        return { success: true, message: 'Like/dislike removed' };
      }
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          is_like: likeState === true
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'Failed to update like/dislike');
      }

      return await response.json();
    }

    revertUIChange(commentId) {
      const pending = this.pendingStates.get(commentId);
      if (!pending) return;

      const { originalState, originalLikes, originalDislikes, likeBtn, dislikeBtn } = pending;
      
      // Revert to original state
      this.updateUIImmediately(
        likeBtn, 
        dislikeBtn, 
        originalState === 'null' ? null : (originalState === 'true'), 
        originalLikes, 
        originalDislikes
      );

      // Clean up
      this.pendingStates.delete(commentId);
      
      // Show error message
      const errorText = translations && translations['comments.error'] 
        ? translations['comments.error']
        : 'Error updating like/dislike';
      showError(errorText);
    }

    // Clean up method for component unmount
    cleanup() {
      this.debounceTimers.forEach(timer => clearTimeout(timer));
      this.debounceTimers.clear();
      this.pendingStates.clear();
    }
  }

  // Initialize debounced likes system
  const debouncedLikes = new DebouncedLikes();

  // Global function to reset comments system (called after language change)
  window.resetCommentsSystem = function() {
    if (isDev) {
      console.log('🔄 Resetting comments system after language change...');
    }
    
    // Clean up previous debounced operations
    if (typeof debouncedLikes !== 'undefined') {
      debouncedLikes.cleanup();
    }
    
    // Reset initialization states
    isInitialized = false;
    isLoadingComments = false;
    currentUser = null;
    
    // Clear any existing timer
    if (initTimer) {
      clearTimeout(initTimer);
    }
    
    // Remove existing event listeners to prevent duplicates
    const commentsContainer = document.getElementById('comments-list');
    if (commentsContainer) {
      // Clone node to remove all event listeners
      const newContainer = commentsContainer.cloneNode(true);
      commentsContainer.parentNode.replaceChild(newContainer, commentsContainer);
    }
    
    const form = document.getElementById('comment-form');
    if (form) {
      // Clone form to remove event listeners
      const newForm = form.cloneNode(true);
      form.parentNode.replaceChild(newForm, form);
    }
    
    // Reinitialize after cleanup - no need for notification system initialization
    setTimeout(() => {
      const container = document.getElementById('comments-list');
      if (container) {
        if (isDev) {
          console.log('🚀 Reinitializing comments system...');
        }
        
        initComments();
      }
    }, 100);
  };

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    // Static notification system is already available - no initialization needed
    if (isDev) console.log('✅ Using static notification system');
    
    // Clear any existing timer
    if (initTimer) {
      clearTimeout(initTimer);
    }
    
    // Debounce initialization to prevent multiple rapid calls
    initTimer = setTimeout(() => {
      // Only initialize if we have a comments container
      const commentsContainer = document.getElementById('comments-list');
      if (!commentsContainer) {
        if (isDev) {
          console.log('No comments container found on DOM load - skipping comments initialization');
        }
        return;
      }
      
      if (isDev) {
        console.log('DOM loaded, initializing comments...');
        console.log('postId:', postId);
        console.log('lang:', lang);
        console.log('translations:', translations);
      }
      
      initComments();
    }, 100);
  });
  
  // Handle Astro page navigation
  document.addEventListener('astro:page-load', () => {
    // Use the global reset function to properly clean up and reinitialize
    if (typeof window.resetCommentsSystem === 'function') {
      if (isDev) {
        console.log('Astro page load, using resetCommentsSystem...');
      }
      window.resetCommentsSystem();
    } else {
      // Fallback to old method if reset function not available
      if (isDev) {
        console.log('Astro page load, using fallback initialization...');
      }
      // Clear any existing timer
      if (initTimer) {
        clearTimeout(initTimer);
      }
      
      initTimer = setTimeout(() => {
        const commentsContainer = document.getElementById('comments-list');
        if (!commentsContainer) {
          if (isDev) {
            console.log('No comments container found on astro:page-load - skipping comments initialization');
          }
          return;
        }
        
        // Clean up previous debounced operations
        if (typeof debouncedLikes !== 'undefined') {
          debouncedLikes.cleanup();
        }
        // Reset both initialization state and user state
        isInitialized = false;
        isLoadingComments = false;
        currentUser = null;
        initComments();
      }, 100);
    }
  });

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    if (typeof debouncedLikes !== 'undefined') {
      debouncedLikes.cleanup();
    }
    if (initTimer) {
      clearTimeout(initTimer);
    }
  });

  // Comments functionality
  async function initComments() {
    // Prevent multiple initializations
    if (isInitialized) {
      if (isDev) {
        console.log('Comments already initialized, skipping...');
      }
      return;
    }
    
    // Check if we're on a page that actually has comments
    const commentsContainer = document.getElementById('comments-list');
    if (!commentsContainer) {
      if (isDev) {
        console.log('No comments container found - skipping comments initialization (probably not a blog post page)');
      }
      return;
    }
    
    // Validate postId
    if (!postId || postId === 'undefined') {
      console.error('Invalid postId:', postId);
      return;
    }
    
    isInitialized = true;
    if (isDev) {
      console.log('Comments system initialized for post:', postId);
    }
    
    // Always check authentication on initialization and wait for it to complete
    await checkAuth();
    
    // Basic form submission handler
    const form = document.getElementById('comment-form');
    if (form) {
      form.addEventListener('submit', handleSubmitComment);
    }

    // Load existing comments after auth check is complete
    loadComments();

    // Add event listeners for interactive elements - use delegation on comments container
    if (commentsContainer) {
      commentsContainer.addEventListener('click', handleCommentActions);
      if (isDev) {
        console.log('✅ Event listener added to comments container');
      }
    }
  }

  async function checkAuth() {
    if (isDev) {
      console.log('🔍 checkAuth: Starting authentication check...');
    }
    
    // Get token from localStorage (client-side only)
    if (typeof window !== 'undefined') {
      const token = localStorage.getItem('access_token');
      
      if (!token) {
        if (isDev) {
          console.log('🔍 No authentication token found');
        }
        currentUser = null;
        updateAuthUI();
        return;
      }

      if (isDev) {
        console.log('🔍 Found token, verifying with API...');
      }

      // Verify token with API (secure)
      try {
        const response = await fetch('http://localhost:8000/api/auth/me', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (response.ok) {
          const userData = await response.json();
          if (isDev) {
            console.log('✅ User authenticated via API:', userData.email, 'Role:', userData.role?.name);
          }
          currentUser = userData;
        } else {
          if (isDev) {
            console.error('❌ Token validation failed:', response.status);
          }
          localStorage.removeItem('access_token');
          currentUser = null;
        }
      } catch (error) {
        if (isDev) {
          console.error('❌ Error verifying token:', error);
        }
        currentUser = null;
      }
      
      if (isDev) {
        console.log('🔍 checkAuth: Authentication check complete. currentUser:', currentUser ? currentUser.email : 'null');
      }
      
      updateAuthUI();
    }
  }

  function updateAuthUI() {
    if (isDev) {
      console.log('🎨 updateAuthUI: Updating UI for user:', currentUser ? currentUser.email : 'null');
    }
    
    const form = document.getElementById('comment-form');
    const loginMessage = document.getElementById('login-required');
    const userAvatarLetter = document.getElementById('user-avatar-letter');
    
    if (form && loginMessage) {
      if (currentUser) {
        form.style.display = 'block';
        loginMessage.style.display = 'none';
        
        // Update user avatar letter
        if (userAvatarLetter) {
          const letter = currentUser.username ? 
            currentUser.username.charAt(0).toUpperCase() : 
            currentUser.email.charAt(0).toUpperCase();
          userAvatarLetter.textContent = letter;
        }
        
        if (isDev) {
          console.log('✅ updateAuthUI: Comment form shown for logged in user');
        }
      } else {
        form.style.display = 'none';
        loginMessage.style.display = 'block';
        
        if (isDev) {
          console.log('❌ updateAuthUI: Login message shown for non-logged user');
        }
      }
    } else {
      if (isDev) {
        console.error('❌ updateAuthUI: Form or login message elements not found');
      }
    }
  }

  async function handleSubmitComment(e) {
    e.preventDefault();
    
    // Check authentication before submitting
    if (!currentUser) {
      const loginRequiredText = translations && translations['comments.loginRequired'] 
        ? translations['comments.loginRequired'] 
        : 'Please login to comment';
      showError(loginRequiredText);
      return;
    }
    
    const formData = new FormData(e.target);
    const content = formData.get('content');

    if (!content) {
      const requiredText = translations && translations['comments.required'] 
        ? translations['comments.required']
        : 'Comment content is required';
      showError(requiredText);
      return;
    }

    // Disable submit button during request
    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    const postingText = translations && translations['comments.posting'] 
      ? translations['comments.posting']
      : 'Posting...';
    submitBtn.disabled = true;
    submitBtn.textContent = postingText;

    try {
      const token = localStorage.getItem('access_token');
      
      if (!token) {
        const loginRequiredText = translations && translations['comments.loginRequired'] 
          ? translations['comments.loginRequired'] 
          : 'Please login to comment';
        showError(loginRequiredText);
        return;
      }
      
      // Use correct API endpoint from apiUrls
      const url = apiUrls.createPostComment;
      console.log('Creating comment at URL:', url);
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          content: content,
          parent_id: null // For now, no replies
        })
      });

      if (response.ok) {
        // Clear form and reload comments
        e.target.reset();
        // Only reload if not already loading
        if (!isLoadingComments) {
          loadComments();
        }
        const successText = translations && translations['comments.success'] 
          ? translations['comments.success']
          : 'Comment added successfully';
        showSuccess(successText);
        
        // Check for rank upgrade after successful comment
        await checkRankUpgrade();
      } else {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'Failed to post comment');
      }
    } catch (error) {
      console.error('Error posting comment:', error);
      const errorText = translations && translations['comments.error'] 
        ? translations['comments.error']
        : 'Error adding comment';
      showError(errorText);
    } finally {
      // Re-enable submit button
      submitBtn.disabled = false;
      submitBtn.textContent = originalText;
    }
  }

  async function loadComments() {
    // Prevent multiple simultaneous loads
    if (isLoadingComments) {
      if (isDev) {
        console.log('⏭️ loadComments: Already loading, skipping...');
      }
      return;
    }

    // Check if comments container exists before trying to load
    const container = document.getElementById('comments-list');
    if (!container) {
      if (isDev) {
        console.log('⏭️ loadComments: No comments container found, skipping...');
      }
      return;
    }

    isLoadingComments = true;
    
    try {
      console.log('Loading comments for post:', postId);
      // Use correct API endpoint from apiUrls with include_replies parameter
      const url = `${apiUrls.getPostComments}?include_replies=true`;
      console.log('API URL:', url);
      
      // Prepare headers - include Authorization if user is logged in
      const headers = {};
      const token = localStorage.getItem('access_token');
      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
        console.log('Loading comments with authentication for user like/dislike status');
      }
      
      const response = await fetch(url, { headers });
      if (response.ok) {
        const comments = await response.json();
        console.log('Comments loaded successfully:', comments);
        displayComments(comments);
      } else {
        console.error('API response not ok:', response.status, response.statusText);
        throw new Error('Failed to load comments');
      }
    } catch (error) {
      console.error('Error loading comments:', error);
      // Only display error in container, don't show popup
      const container = document.getElementById('comments-list');
      if (container) {
        const errorMessage = translations && translations['comments.error'] 
          ? translations['comments.error'] 
          : 'Error loading comments. Please try again.';
        container.innerHTML = `<p class="text-red-500">${errorMessage}</p>`;
      }
    } finally {
      isLoadingComments = false;
    }
  }

  function displayComments(comments) {
    if (isDev) {
      console.log('🎨 displayComments: Rendering comments. currentUser:', currentUser ? currentUser.email : 'null');
    }
    
    const container = document.getElementById('comments-list');
    if (!container) {
      console.error('Comments container not found');
      return;
    }

    if (comments.length === 0) {
      const noCommentsText = translations && translations['comments.noComments'] 
        ? translations['comments.noComments'] 
        : 'No comments yet';
      container.innerHTML = `<p class="text-gray-500 italic text-center py-8">${noCommentsText}</p>`;
      return;
    }

    if (isDev) {
      console.log('All comments with nested replies:', comments);
    }

    const renderComment = (comment, isReply = false) => {
      // Replies są już zagnieżdżone w comment.replies
      const commentReplies = comment.replies || [];
      const hasReplies = commentReplies.length > 0;
      
      // Check if comment is deleted
      const isDeleted = comment.is_deleted || comment.deleted || false;
      
      // If comment is deleted, show deleted message
      if (isDeleted) {
        const deletedMessage = translations && translations['comments.deleted'] 
          ? translations['comments.deleted'] 
          : 'This comment has been deleted';
        
        return `
          <div class="comment-wrapper ${isReply ? 'ml-12' : ''}" data-comment-id="${comment.id}">
            <div class="relative bg-gray-100 dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 p-4 mb-3">
              <div class="flex items-center space-x-2 text-gray-500 dark:text-gray-400 italic text-sm">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                </svg>
                <span>${deletedMessage}</span>
              </div>
            </div>
            
            <!-- Show replies even if parent comment is deleted -->
            ${hasReplies && !isReply ? `
              <div class="replies-container ml-8 mt-3" data-parent-id="${comment.id}">
                <div class="border-l-4 border-gray-300 dark:border-gray-600 pl-6 space-y-3">
                  ${commentReplies.map(reply => renderComment(reply, true)).join('')}
                </div>
              </div>
            ` : ''}
          </div>
        `;
      }
      
      // Mapowanie danych autora zgodnie z dokumentacją API
      const authorName = comment.author?.username || 'Anonymous';
      const authorRole = comment.author?.role?.name || 'user';
      const authorDisplayRole = comment.author?.role?.display_name || authorRole;
      const authorRoleColor = comment.author?.role?.color || '#6b7280';
      const authorRank = comment.author?.rank?.name || 'newbie';
      const authorDisplayRank = comment.author?.rank?.display_name || authorRank;
      const authorRankIcon = comment.author?.rank?.icon || '🆕';
      
      if (isDev) {
        console.log(`Rendering comment ${comment.id} (isReply: ${isReply}), has ${commentReplies.length} replies`);
      }
      
      return `
        <div class="comment-wrapper ${isReply ? 'ml-12' : ''}" data-comment-id="${comment.id}">
          <!-- Comment Card -->
          <div class="relative bg-white dark:bg-gray-800 rounded-xl shadow-sm border ${authorRole === 'admin' || authorRole === 'superadmin' ? 'border-red-200 dark:border-red-700 bg-red-50/30 dark:bg-red-900/10' : authorRole === 'moderator' ? 'border-green-200 dark:border-green-700 bg-green-50/30 dark:bg-green-900/10' : 'border-gray-100 dark:border-gray-700'} p-4 mb-3 hover:shadow-md transition-shadow">
            ${authorRole === 'admin' || authorRole === 'superadmin' ? '<div class="absolute top-2 right-2"><svg class="w-4 h-4 text-red-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M9.504 1.132a1 1 0 01.992 0l1.75 1a1 1 0 11-.992 1.736L10 3.152l-1.254.716a1 1 0 11-.992-1.736l1.75-1zM5.618 4.504a1 1 0 01-.372 1.364L5.016 6l.23.132a1 1 0 11-.992 1.736L3 7.723V8a1 1 0 01-2 0V6a.996.996 0 01.52-.878l1.734-.99a1 1 0 011.364.372zm8.764 0a1 1 0 011.364-.372l1.733.99A1.002 1.002 0 0118 6v2a1 1 0 11-2 0v-.277l-1.254.145a1 1 0 11-.992-1.736L14.984 6l-.23-.132a1 1 0 01-.372-1.364zm-7 4a1 1 0 011.364-.372L10 8.848l1.254-.716a1 1 0 11.992 1.736L11 10.477V12a1 1 0 11-2 0V10.477L7.746 9.868a1 1 0 01-.364-1.364zm2.286 6.708a1 1 0 01.372-1.364L11 13.152l1.254.716a1 1 0 11-.992 1.736L10 14.888l-1.254.716a1 1 0 01-1.364-.372l.746-1.292z" clip-rule="evenodd"></path></svg></div>' : authorRole === 'moderator' ? '<div class="absolute top-2 right-2"><svg class="w-4 h-4 text-green-500" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M2.166 4.999A11.954 11.954 0 0010 1.944 11.954 11.954 0 0017.834 5c.11.65.166 1.32.166 2.001 0 5.225-3.34 9.67-8 11.317C5.34 16.67 2 12.225 2 7c0-.682.057-1.35.166-2.001zm11.541 3.708a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg></div>' : ''}
            <!-- User Info Header -->
            <div class="flex items-start space-x-3 mb-3">
              <!-- Avatar -->
              <div class="flex-shrink-0">
                <div class="w-8 h-8 ${authorRole === 'admin' || authorRole === 'superadmin' ? 'bg-gradient-to-br from-red-500 to-orange-600' : authorRole === 'moderator' ? 'bg-gradient-to-br from-green-500 to-emerald-600' : 'bg-gradient-to-br from-blue-500 to-purple-600'} rounded-full flex items-center justify-center text-white text-sm font-semibold">
                  ${authorName.charAt(0).toUpperCase()}
                </div>
              </div>
              
              <!-- User Details -->
              <div class="flex-1 min-w-0">
                <div class="flex items-center space-x-2">
                  <h4 class="font-semibold text-gray-900 dark:text-gray-100 text-sm">
                    ${authorName}
                  </h4>
                  ${authorRole && authorRole !== 'user' ? `<span class="px-2 py-1 rounded-full text-xs font-semibold" style="background-color: ${authorRoleColor}20; color: ${authorRoleColor}; border: 1px solid ${authorRoleColor}40;">${authorDisplayRole}</span>` : ''}
                  ${authorRank && authorRank !== 'newbie' ? `<span class="px-2 py-1 bg-amber-100 dark:bg-amber-900 text-amber-700 dark:text-amber-300 text-xs rounded-full font-medium">${authorRankIcon} ${authorDisplayRank}</span>` : ''}
                  ${isReply ? '<span class="px-2 py-1 bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 text-xs rounded-full">Reply</span>' : ''}
                </div>
                <p class="text-xs text-gray-500 dark:text-gray-400">
                  ${formatDate(comment.created_at)}
                </p>
              </div>
            </div>

            <!-- Comment Content -->
            <div class="mb-3 ml-11">
              <p class="text-gray-800 dark:text-gray-200 text-sm leading-relaxed whitespace-pre-wrap">
                ${comment.content}
              </p>
            </div>

            <!-- Action Buttons -->
            <div class="flex items-center justify-between ml-11">
              <div class="flex items-center space-x-2">
                <!-- Sprawdź czy użytkownik jest właścicielem komentarza -->
                ${comment.author?.id && currentUser && comment.author.id === currentUser.id ? `
                  <!-- Własny komentarz - pokazuj tylko liczby bez przycisków -->
                  <div class="flex items-center space-x-2 px-4 py-2.5 rounded-xl bg-gray-50 dark:bg-gray-800 border-2 border-gray-200 dark:border-gray-600 text-sm font-semibold text-gray-500 dark:text-gray-400">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L9 7m5 3v4M9 7H5a2 2 0 00-2 2v6a2 2 0 002 2h2.5"></path>
                    </svg>
                    <span class="font-bold">${comment.likes_count || 0}</span>
                    <span class="text-xs">${translations && translations['comments.likes'] ? translations['comments.likes'] : 'likes'}</span>
                  </div>
                  <div class="flex items-center space-x-2 px-4 py-2.5 rounded-xl bg-gray-50 dark:bg-gray-800 border-2 border-gray-200 dark:border-gray-600 text-sm font-semibold text-gray-500 dark:text-gray-400">
                    <svg class="w-5 h-5 rotate-180" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L9 7m5 3v4M9 7H5a2 2 0 00-2 2v6a2 2 0 002 2h2.5"></path>
                    </svg>
                    <span class="font-bold">${comment.dislikes_count || 0}</span>
                    <span class="text-xs">${translations && translations['comments.dislikes'] ? translations['comments.dislikes'] : 'dislikes'}</span>
                  </div>
                ` : `
                  <!-- Komentarz innego użytkownika - pokazuj przyciski -->
                  <!-- Like Button - BIGGER and MORE VISIBLE -->
                <button 
                  class="like-btn flex items-center space-x-2 px-4 py-2.5 rounded-xl hover:bg-gray-100 dark:hover:bg-gray-700 transition-all duration-200 text-sm font-semibold border-2 ${comment.user_like_status === true ? 'text-blue-600 bg-blue-50 dark:bg-blue-900/30 border-blue-200 dark:border-blue-700' : 'text-gray-600 dark:text-gray-400 border-gray-200 dark:border-gray-600'}" 
                  data-action="like" 
                  data-id="${comment.id}"
                  data-current-state="${comment.user_like_status}"
                >
                  <svg class="w-5 h-5" fill="${comment.user_like_status === true ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L9 7m5 3v4M9 7H5a2 2 0 00-2 2v6a2 2 0 002 2h2.5"></path>
                  </svg>
                  <span class="like-count font-bold">${comment.likes_count || 0}</span>
                </button>

                <!-- Dislike Button - BIGGER and MORE VISIBLE -->
                <button 
                  class="dislike-btn flex items-center space-x-2 px-4 py-2.5 rounded-xl hover:bg-gray-100 dark:hover:bg-gray-700 transition-all duration-200 text-sm font-semibold border-2 ${comment.user_like_status === false ? 'text-red-600 bg-red-50 dark:bg-red-900/30 border-red-200 dark:border-red-700' : 'text-gray-600 dark:text-gray-400 border-gray-200 dark:border-gray-600'}" 
                  data-action="dislike" 
                  data-id="${comment.id}"
                  data-current-state="${comment.user_like_status}"
                >
                  <svg class="w-5 h-5 rotate-180" fill="${comment.user_like_status === false ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 10h4.764a2 2 0 011.789 2.894l-3.5 7A2 2 0 0115.263 21h-4.017c-.163 0-.326-.02-.485-.06L7 20m7-10V5a2 2 0 00-2-2h-.095c-.5 0-.905.405-.905.905 0 .714-.211 1.412-.608 2.006L9 7m5 3v4M9 7H5a2 2 0 00-2 2v6a2 2 0 002 2h2.5"></path>
                  </svg>
                  <span class="dislike-count font-bold">${comment.dislikes_count || 0}</span>
                </button>
                `}

                ${!isReply ? `
                  <!-- Reply Button -->
                  <button 
                    class="reply-btn flex items-center space-x-2 px-4 py-2.5 rounded-xl hover:bg-gray-100 dark:hover:bg-gray-700 transition-all duration-200 text-sm font-medium text-gray-600 dark:text-gray-400 border-2 border-gray-200 dark:border-gray-600" 
                    data-action="reply" 
                    data-id="${comment.id}"
                  >
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                    </svg>
                    <span>${translations && translations['comments.reply'] ? translations['comments.reply'] : 'Reply'}</span>
                  </button>
                ` : ''}

                <!-- Edit/Delete buttons - używaj can_edit i can_delete z backendu -->
                ${currentUser && (comment.can_edit || comment.can_delete) ? `
                  <div class="flex items-center space-x-2 ml-2 border-l border-gray-300 dark:border-gray-600 pl-2">
                    <!-- Edit Button - pokazuj tylko gdy backend pozwala (can_edit) -->
                    ${comment.can_edit ? `
                      <button 
                        class="edit-btn flex items-center space-x-1 px-3 py-2 rounded-lg hover:bg-yellow-100 dark:hover:bg-yellow-900/30 transition-all duration-200 text-xs font-medium text-yellow-600 dark:text-yellow-400 border border-yellow-200 dark:border-yellow-700" 
                        data-action="edit" 
                        data-id="${comment.id}"
                        title="${translations && translations['comments.edit'] ? translations['comments.edit'] : 'Edit comment'}"
                      >
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                        </svg>
                        <span>${translations && translations['comments.edit'] ? translations['comments.edit'] : 'Edit'}</span>
                      </button>
                    ` : ''}
                    
                    <!-- Delete Button - pokazuj tylko gdy backend pozwala (can_delete) -->
                    ${comment.can_delete ? `
                      <button 
                        class="delete-btn flex items-center space-x-1 px-3 py-2 rounded-lg hover:bg-red-100 dark:hover:bg-red-900/30 transition-all duration-200 text-xs font-medium text-red-600 dark:text-red-400 border border-red-200 dark:border-red-700" 
                        data-action="delete" 
                        data-id="${comment.id}"
                        title="${translations && translations['comments.delete'] ? translations['comments.delete'] : 'Delete comment'}"
                      >
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                        <span>${translations && translations['comments.delete'] ? translations['comments.delete'] : 'Delete'}</span>
                      </button>
                    ` : ''}
                  </div>
                ` : ''}
              </div>
            </div>
          </div>

          <!-- Replies Container - ALWAYS SHOW REPLIES -->
          ${hasReplies && !isReply ? `
            <div class="replies-container ml-8 mt-3" data-parent-id="${comment.id}">
              <div class="border-l-4 border-blue-200 dark:border-blue-600 pl-6 space-y-3">
                ${commentReplies.map(reply => renderComment(reply, true)).join('')}
              </div>
            </div>
          ` : ''}
        </div>
      `;
    };

    // Renderuj tylko główne komentarze (parent_id === null)
    const mainComments = comments.filter(comment => comment.parent_id === null || comment.parent_id === undefined);
    if (isDev) {
      console.log('Main comments to render:', mainComments.length);
    }
    container.innerHTML = mainComments.map(comment => renderComment(comment)).join('');
  }

  function handleCommentActions(e) {
    // Skip events from reply forms
    if (e.target.closest('.reply-form')) {
      console.log('🚫 Skipping event from reply form');
      return;
    }
    
    console.log('🖱️ Click detected on:', e.target);
    
    // Find the button element (might be clicked on SVG or span inside)
    let button = e.target;
    if (!button.dataset.action) {
      button = button.closest('button[data-action]');
    }
    
    if (!button || !button.dataset.action || !button.dataset.id) {
      console.log('❌ No valid button found:', button);
      return;
    }

    // Only prevent default for comment action buttons
    e.preventDefault();
    e.stopPropagation();

    const action = button.dataset.action;
    const commentId = button.dataset.id;
    
    console.log(`🎯 Action: ${action}, Comment ID: ${commentId}`);

    switch (action) {
      case 'like':
      case 'dislike':
        console.log(`💝 Handling ${action} for comment ${commentId}`);
        handleLikeDislike(commentId, action);
        break;
      case 'reply':
        console.log(`💬 Handling reply for comment ${commentId}`);
        handleReply(commentId);
        break;
      case 'edit':
        console.log(`✏️ Handling edit for comment ${commentId}`);
        handleEditComment(commentId);
        break;
      case 'delete':
        console.log(`🗑️ Handling delete for comment ${commentId}`);
        handleDeleteComment(commentId);
        break;
      default:
        console.log('❌ Unknown action:', action);
    }
  }

  async function handleLikeDislike(commentId, action) {
    try {
      console.log(`🚀 handleLikeDislike called: commentId=${commentId}, action=${action}`);
      
      // Check authentication before like/dislike
      if (!currentUser) {
        if (isDev) {
          console.log('❌ User not authenticated for like/dislike');
        }
        const loginRequiredText = translations && translations['comments.loginRequiredToLike'] 
          ? translations['comments.loginRequiredToLike']
          : (action === 'like' ? 'Please login to like comments' : 'Please login to dislike comments');
        showError(loginRequiredText);
        return;
      }

      const token = localStorage.getItem('access_token');
      
      if (!token) {
        if (isDev) {
          console.log('❌ No access token found for like/dislike');
        }
        const loginRequiredText = translations && translations['comments.loginRequiredToLike'] 
          ? translations['comments.loginRequiredToLike'] 
          : (action === 'like' ? 'Please login to like comments' : 'Please login to dislike comments');
        showError(loginRequiredText);
        return;
      }

      console.log(`✅ User authenticated, calling debounced system`);
      // Use debounced system for better UX and performance
      console.log(`🎯 Debounced ${action} triggered for comment ${commentId}`);
      await debouncedLikes.debouncedToggleLike(commentId, action);
      
    } catch (error) {
      console.error('❌ Error in handleLikeDislike:', error);
      const errorText = translations && translations['comments.error'] 
        ? translations['comments.error']
        : 'Error updating like/dislike';
      showError(errorText);
    }
  }

  function handleReply(commentId) {
    console.log('Reply to comment:', commentId);
    
    // Check authentication
    if (!currentUser) {
      const loginRequiredText = translations && translations['comments.loginRequired'] 
        ? translations['comments.loginRequired'] 
        : 'Please login to reply';
      showError(loginRequiredText);
      return;
    }
    
    // Find the comment element
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (!commentElement) {
      console.error('Comment element not found for ID:', commentId);
      return;
    }
    
    // Check if reply form already exists
    const existingReplyForm = commentElement.querySelector('.reply-form');
    if (existingReplyForm) {
      existingReplyForm.remove(); // Remove existing form
      return;
    }
    
    // Create reply form
    const replyForm = document.createElement('div');
    replyForm.className = 'reply-form mt-4 bg-gray-50 dark:bg-gray-900 rounded-xl p-4 border border-gray-200 dark:border-gray-700';
    replyForm.innerHTML = `
      <div class="flex items-start space-x-3">
        <!-- User Avatar -->
        <div class="flex-shrink-0">
          <div class="w-7 h-7 bg-gradient-to-br from-green-500 to-blue-600 rounded-full flex items-center justify-center text-white text-xs font-semibold">
            ${currentUser.username ? currentUser.username.charAt(0).toUpperCase() : currentUser.email.charAt(0).toUpperCase()}
          </div>
        </div>
        
        <!-- Reply Form Content -->
        <div class="flex-1">
          <form class="reply-form-content">
            <div class="mb-3">
              <textarea 
                name="reply-content" 
                rows="3" 
                class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-800 dark:text-gray-100 text-sm resize-none placeholder-gray-500 dark:placeholder-gray-400"
                placeholder="${translations && translations['comments.writeReply'] ? translations['comments.writeReply'] : 'Write your reply...'}"
                required
              ></textarea>
            </div>
            <div class="flex items-center justify-between">
              <div class="flex space-x-2">
                <button 
                  type="submit" 
                  class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-1"
                >
                  <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                  </svg>
                  <span>${translations && translations['comments.submitReply'] ? translations['comments.submitReply'] : 'Reply'}</span>
                </button>
                <button 
                  type="button" 
                  class="cancel-reply bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200"
                >
                  ${translations && translations['comments.cancel'] ? translations['comments.cancel'] : 'Cancel'}
                </button>
              </div>
              <div class="text-xs text-gray-500 dark:text-gray-400">
                ${translations && translations['comments.replyTo'] ? translations['comments.replyTo'] : 'Replying to'} <strong>${commentElement.querySelector('h4').textContent}</strong>
              </div>
            </div>
          </form>
        </div>
      </div>
    `;
    
    // Add reply form to comment
    commentElement.appendChild(replyForm);
    
    // Add event listeners
    const form = replyForm.querySelector('.reply-form-content');
    const cancelBtn = replyForm.querySelector('.cancel-reply');
    
    form.addEventListener('submit', (e) => handleSubmitReply(e, commentId));
    cancelBtn.addEventListener('click', () => replyForm.remove());
    
    // Focus on textarea
    const textarea = replyForm.querySelector('textarea');
    textarea.focus();
  }

  async function handleSubmitReply(e, parentCommentId) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const content = formData.get('reply-content');
    
    if (!content || !content.trim()) {
      const requiredText = translations && translations['comments.required'] 
        ? translations['comments.required']
        : 'Reply content is required';
      showError(requiredText);
      return;
    }

    // Disable submit button during request
    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    const postingText = translations && translations['comments.posting'] 
      ? translations['comments.posting']
      : 'Posting...';
    submitBtn.disabled = true;
    submitBtn.textContent = postingText;

    try {
      const token = localStorage.getItem('access_token');
      
      if (!token) {
        const loginRequiredText = translations && translations['comments.loginRequired'] 
          ? translations['comments.loginRequired'] 
          : 'Please login to reply';
        showError(loginRequiredText);
        return;
      }
      
      // Use the same createPostComment endpoint but with parent_id
      const url = apiUrls.createPostComment;
      console.log('Creating reply at URL:', url, 'for parent:', parentCommentId);
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          content: content.trim(),
          parent_id: parseInt(parentCommentId) // ID komentarza na który odpowiadamy
        })
      });

      if (response.ok) {
        // Remove reply form and reload comments
        const replyForm = e.target.closest('.reply-form');
        replyForm.remove();
        // Only reload if not already loading
        if (!isLoadingComments) {
          loadComments();
        }
        const successText = translations && translations['comments.replySuccess'] 
          ? translations['comments.replySuccess']
          : 'Reply added successfully';
        showSuccess(successText);
        
        // Check for rank upgrade after successful reply
        await checkRankUpgrade();
      } else {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'Failed to post reply');
      }
    } catch (error) {
      console.error('Error posting reply:', error);
      const errorText = translations && translations['comments.error'] 
        ? translations['comments.error']
        : 'Error adding reply';
      showError(errorText);
    } finally {
      // Re-enable submit button
      submitBtn.disabled = false;
      submitBtn.textContent = originalText;
    }
  }

  async function checkRankUpgrade() {
    try {
      if (!currentUser) return;
      
      const token = localStorage.getItem('access_token');
      if (!token) return;
      
      console.log('🎯 Checking rank upgrade for user...');
      
      const response = await fetch('http://localhost:8000/api/roles/check-rank-upgrade/me', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('🎉 Rank upgrade check result:', result);
        
        if (result.upgraded) {
          // Show upgrade notification
          const upgradeMessage = lang === 'pl' 
            ? `🎉 Gratulacje! Awansowałeś na ${result.new_rank_display || result.new_rank}!`
            : `🎉 Congratulations! You've been promoted to ${result.new_rank_display || result.new_rank}!`;
          
          showSuccess(upgradeMessage);
          
          // Update current user info
          currentUser.rank = result.new_rank;
          currentUser.display_rank = result.new_rank_display;
          currentUser.rank_icon = result.new_rank_icon;
          
          console.log('✅ User rank updated in currentUser object');
        }
        
        return result;
      } else {
        console.log('❌ Rank upgrade check failed:', response.status);
      }
    } catch (error) {
      console.error('❌ Error checking rank upgrade:', error);
    }
  }

  async function handleEditComment(commentId) {
    console.log('Editing comment:', commentId);
    
    // Check authentication and permissions
    if (!currentUser) {
      const loginRequiredText = translations && translations['comments.loginRequired'] 
        ? translations['comments.loginRequired'] 
        : 'Please login to edit comments';
      showError(loginRequiredText);
      return;
    }
    
    // Find the comment element
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    if (!commentElement) {
      console.error('Comment element not found for ID:', commentId);
      return;
    }
    
    // Get current comment content - target the content paragraph specifically
    const contentElement = commentElement.querySelector('.mb-3.ml-11 p');
    const currentContent = contentElement.textContent.trim();
    
    // Check if edit form already exists
    const existingEditForm = commentElement.querySelector('.edit-form');
    if (existingEditForm) {
      existingEditForm.remove(); // Remove existing form
      contentElement.style.display = 'block'; // Show original content
      return;
    }
    
    // Hide original content
    contentElement.style.display = 'none';
    
    // Create edit form
    const editForm = document.createElement('div');
    editForm.className = 'edit-form mt-2 mb-4';
    editForm.innerHTML = `
      <form class="edit-form-content">
        <div class="mb-3">
          <textarea 
            name="edit-content" 
            rows="3" 
            class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:border-transparent dark:bg-gray-800 dark:text-gray-100 text-sm resize-none placeholder-gray-500 dark:placeholder-gray-400"
            placeholder="${translations && translations['comments.editPlaceholder'] ? translations['comments.editPlaceholder'] : 'Edit your comment...'}"
            required
          >${currentContent}</textarea>
        </div>
        <div class="flex items-center justify-between">
          <div class="flex space-x-2">
            <button 
              type="submit" 
              class="bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-1"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
              </svg>
              <span>${translations && translations['comments.saveEdit'] ? translations['comments.saveEdit'] : 'Save'}</span>
            </button>
            <button 
              type="button" 
              class="cancel-edit bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200"
            >
              ${translations && translations['comments.cancel'] ? translations['comments.cancel'] : 'Cancel'}
            </button>
          </div>
          <div class="text-xs text-gray-500 dark:text-gray-400">
            ${translations && translations['comments.editTime'] ? translations['comments.editTime'] : 'Edit within 15 minutes of posting'}
          </div>
        </div>
      </form>
    `;
    
    // Add edit form after the content
    contentElement.parentNode.insertBefore(editForm, contentElement.nextSibling);
    
    // Add event listeners
    const form = editForm.querySelector('.edit-form-content');
    const cancelBtn = editForm.querySelector('.cancel-edit');
    
    form.addEventListener('submit', (e) => handleSubmitEdit(e, commentId, contentElement, editForm));
    cancelBtn.addEventListener('click', () => {
      editForm.remove();
      contentElement.style.display = 'block';
    });
    
    // Focus on textarea and select all text for easy editing
    const textarea = editForm.querySelector('textarea');
    textarea.focus();
    textarea.select();
  }

  async function handleSubmitEdit(e, commentId, originalContentElement, editForm) {
    e.preventDefault();
    
    const formData = new FormData(e.target);
    const content = formData.get('edit-content');
    
    if (!content || !content.trim()) {
      const requiredText = translations && translations['comments.required'] 
        ? translations['comments.required']
        : 'Comment content is required';
      showError(requiredText);
      return;
    }

    // Disable submit button during request
    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    const savingText = translations && translations['comments.saving'] 
      ? translations['comments.saving']
      : 'Saving...';
    submitBtn.disabled = true;
    submitBtn.textContent = savingText;

    try {
      const token = localStorage.getItem('access_token');
      
      if (!token) {
        const loginRequiredText = translations && translations['comments.loginRequired'] 
          ? translations['comments.loginRequired'] 
          : 'Please login to edit comments';
        showError(loginRequiredText);
        return;
      }
      
      // Use update endpoint
      const url = apiUrls.updateCommentTemplate.replace('{id}', commentId);
      console.log('Updating comment at URL:', url);
      
      const response = await fetch(url, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          content: content.trim()
        })
      });

      if (response.ok) {
        // Update the content in DOM
        originalContentElement.textContent = content.trim();
        originalContentElement.style.display = 'block';
        editForm.remove();
        
        const successText = translations && translations['comments.editSuccess'] 
          ? translations['comments.editSuccess']
          : 'Comment updated successfully';
        showSuccess(successText);
      } else {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'Failed to update comment');
      }
    } catch (error) {
      console.error('Error updating comment:', error);
      const errorText = translations && translations['comments.error'] 
        ? translations['comments.error']
        : 'Error updating comment';
      showError(errorText);
    } finally {
      // Re-enable submit button
      submitBtn.disabled = false;
      submitBtn.textContent = originalText;
    }
  }

  async function handleDeleteComment(commentId) {
    console.log('Deleting comment:', commentId);
    
    // Check authentication and permissions
    if (!currentUser) {
      const loginRequiredText = translations && translations['comments.loginRequired'] 
        ? translations['comments.loginRequired']
        : 'Please login to delete comments';
      showError(loginRequiredText);
      return;
    }    // Show confirmation dialog
    const confirmText = translations && translations['comments.deleteConfirm'] 
      ? translations['comments.deleteConfirm']
      : 'Are you sure you want to delete this comment? This action cannot be undone.';
    
    if (!confirm(confirmText)) {
      return;
    }

    try {
      const token = localStorage.getItem('access_token');
      
      if (!token) {
        const loginRequiredText = translations && translations['comments.loginRequired'] 
          ? translations['comments.loginRequired'] 
          : 'Please login to delete comments';
        showError(loginRequiredText);
        return;
      }
      
      // Use delete endpoint
      const url = apiUrls.deleteCommentTemplate.replace('{id}', commentId);
      console.log('Deleting comment at URL:', url);
      
      const response = await fetch(url, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (response.ok) {
        // Remove the comment from DOM or reload comments
        // Only reload if not already loading
        if (!isLoadingComments) {
          loadComments();
        }
        
        const successText = translations && translations['comments.deleteSuccess'] 
          ? translations['comments.deleteSuccess']
          : 'Comment deleted successfully';
        showSuccess(successText);
      } else {
        const errorData = await response.json();
        throw new Error(errorData.detail || 'Failed to delete comment');
      }
    } catch (error) {
      console.error('Error deleting comment:', error);
      const errorText = translations && translations['comments.error'] 
        ? translations['comments.error']
        : 'Error deleting comment';
      showError(errorText);
    }
  }

  function formatDate(dateString) {
    const date = new Date(dateString);
    const locale = lang === 'pl' ? 'pl-PL' : 'en-US';
    
    return date.toLocaleDateString(locale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  function showSuccess(message) {
    // Use static notification system - always available
    if (window.StaticNotifications) {
      window.StaticNotifications.success(message);
    } else if (window.NotificationManager) {
      // Legacy fallback
      window.NotificationManager.success(message);
    } else {
      // Final fallback to alert
      alert(message);
    }
  }

  function showError(message) {
    // Use static notification system - always available
    if (window.StaticNotifications) {
      window.StaticNotifications.error(message);
    } else if (window.NotificationManager) {
      // Legacy fallback
      window.NotificationManager.error(message);
    } else {
      // Final fallback to alert
      alert(message);
    }
  }
</script>

<section class="comments-section mt-16 bg-gray-50 dark:bg-gray-900 rounded-2xl p-8 border-t-4 border-blue-500">
  <div class="max-w-4xl mx-auto">
    <div class="flex items-center space-x-3 mb-8">
      <div class="p-2 bg-blue-100 dark:bg-blue-900 rounded-lg">
        <svg class="w-6 h-6 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path>
        </svg>
      </div>
      <h3 class="text-2xl font-bold text-gray-900 dark:text-gray-100">
        {t['comments.title']}
      </h3>
    </div>

  <!-- Login Required Message -->
  <div id="login-required" class="mb-8 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-6">
    <div class="flex items-center">
      <svg class="w-5 h-5 text-yellow-600 dark:text-yellow-400 mr-3" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
      </svg>
      <div>
        <h4 class="text-lg font-medium text-yellow-800 dark:text-yellow-200">
          {lang.toString() === 'pl' ? 'Wymagane logowanie' : 'Login Required'}
        </h4>
        <p class="text-yellow-700 dark:text-yellow-300 mt-1">
          {lang.toString() === 'pl' 
            ? 'Musisz być zalogowany, aby dodać komentarz.' 
            : 'You must be logged in to add a comment.'
          }
        </p>
        <a 
          href={`/${lang}/login`}
          class="inline-block mt-3 bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
        >
          {lang.toString() === 'pl' ? 'Zaloguj się' : 'Login'}
        </a>
      </div>
    </div>
  </div>

  <!-- Comment Form (hidden by default, shown when authenticated) -->
  <form id="comment-form" class="mb-8 bg-white dark:bg-gray-800 rounded-xl shadow-sm border border-gray-200 dark:border-gray-700 p-6" style="display: none;">
    <div class="flex items-start space-x-4">
      <!-- User Avatar -->
      <div class="flex-shrink-0 pt-1">
        <div class="w-10 h-10 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center text-white font-semibold">
          <!-- Will be filled by JavaScript -->
          <span id="user-avatar-letter">U</span>
        </div>
      </div>
      
      <!-- Form Content -->
      <div class="flex-1">
        <div class="mb-4">
          <textarea
            id="content"
            name="content"
            rows="4"
            required
            class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent dark:bg-gray-700 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 resize-none text-sm"
            placeholder={t['comments.writeComment']}
          ></textarea>
        </div>

        <div class="flex items-center justify-between">
          <div class="flex items-center space-x-3">
            <button
              type="submit"
              class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2.5 rounded-lg font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2 text-sm"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
              </svg>
              <span>{t['comments.submitComment']}</span>
            </button>
            
            <!-- Character count (optional) -->
            <span class="text-xs text-gray-500 dark:text-gray-400 hidden" id="char-count">
              0 / 1000
            </span>
          </div>
          
          <div class="text-xs text-gray-500 dark:text-gray-400">
            {lang.toString() === 'pl' ? 'Bądź uprzejmy i konstruktywny' : 'Be kind and constructive'}
          </div>
        </div>
      </div>
    </div>
  </form>

  <!-- Comments List -->
  <div id="comments-list" class="space-y-4">
    <!-- Comments will be loaded here -->
    <div class="text-center py-8">
      <div class="inline-flex items-center space-x-2 text-gray-500 dark:text-gray-400">
        <svg class="w-5 h-5 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
        </svg>
        <span class="text-sm">{t['comments.loading']}</span>
      </div>
    </div>
  </div>
  </div>
</section>
