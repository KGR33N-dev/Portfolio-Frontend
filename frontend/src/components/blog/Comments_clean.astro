---
import type { Language } from '../../types/language';
import { blogTranslations } from '../../i18n/pages/blog';
import { API_URLS } from '../../config/api';

interface Props {
  postId: number;
  lang: Language;
}

const { postId, lang } = Astro.props;

// Access translations
const t = blogTranslations[lang as unknown as 'en' | 'pl'];

// Get API URLs for client-side use
const apiUrls = {
  getPostComments: API_URLS.getPostComments(postId),
  createPostComment: API_URLS.createPostComment(postId),
  likeComment: (commentId: number) => API_URLS.likeComment(commentId),
  updateComment: (commentId: number) => API_URLS.updatePostComment(commentId),
  deleteComment: (commentId: number) => API_URLS.deletePostComment(commentId)
};
---

<script define:vars={{ 
  postId, 
  lang,
  translations: t,
  apiUrls
}}>
  let currentUser = null;
  let isInitialized = false;

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing comments...');
    console.log('postId:', postId);
    console.log('lang:', lang);
    console.log('translations:', translations);
    
    // Ma≈Çe op√≥≈∫nienie, aby localStorage by≈Ç gotowy
    setTimeout(() => {
      initComments();
    }, 100);
  });
  
  // Handle Astro page navigation
  document.addEventListener('astro:page-load', () => {
    console.log('Astro page load, resetting and initializing...');
    isInitialized = false;
    // Ma≈Çe op√≥≈∫nienie na nawigacjƒô Astro
    setTimeout(() => {
      initComments();
    }, 150);
  });

  // Comments functionality
  function initComments() {
    // Prevent multiple initializations
    if (isInitialized) {
      console.log('Comments already initialized, skipping...');
      return;
    }
    
    // Validate postId
    if (!postId || postId === 'undefined') {
      console.error('Invalid postId:', postId);
      return;
    }
    
    isInitialized = true;
    console.log('Comments system initialized for post:', postId);
    
    // Clean up old token format (remove old localStorage keys if they exist)
    if (localStorage.getItem('admin_token')) {
      console.log('üßπ Removing old admin_token...');
      localStorage.removeItem('admin_token');
    }
    if (localStorage.getItem('admin_user')) {
      console.log('üßπ Removing old admin_user...');
      localStorage.removeItem('admin_user');
    }
    
    // Check authentication
    checkAuth();
    
    // Basic form submission handler
    const form = document.getElementById('comment-form');
    if (form) {
      form.addEventListener('submit', handleSubmitComment);
    }

    // Load existing comments
    loadComments();

    // Add event listeners for interactive elements
    document.addEventListener('click', handleCommentActions);
  }

  async function checkAuth() {
    // Get token from localStorage (client-side only)
    if (typeof window !== 'undefined') {
      const token = localStorage.getItem('access_token');
      
      console.log('üîç CheckAuth Debug:');
      console.log('access_token exists:', !!token);
      
      if (!token) {
        console.log('‚ùå No token found');
        currentUser = null;
        updateAuthUI();
        return;
      }

      // Verify token with API (secure)
      try {
        console.log('üîç Verifying token with API...');
        const response = await fetch('http://localhost:8000/api/auth/me', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (response.ok) {
          const userData = await response.json();
          console.log('‚úÖ User authenticated via API:', userData.email, 'User ID:', userData.id);
          currentUser = userData;
        } else {
          console.error('‚ùå Token validation failed:', response.status, response.statusText);
          // Token is invalid, clear localStorage
          localStorage.removeItem('access_token');
          currentUser = null;
        }
      } catch (error) {
        console.error('‚ùå Error verifying token:', error);
        currentUser = null;
      }
      
      // Update UI based on auth status
      updateAuthUI();
    }
  }

  function updateAuthUI() {
    const form = document.getElementById('comment-form');
    const loginMessage = document.getElementById('login-required');
    
    console.log('üé® UpdateAuthUI Debug:');
    console.log('Current user:', currentUser);
    console.log('Form element:', !!form);
    console.log('Login message element:', !!loginMessage);
    
    if (form && loginMessage) {
      if (currentUser) {
        console.log('‚úÖ Showing comment form for authenticated user');
        form.style.display = 'block';
        loginMessage.style.display = 'none';
      } else {
        console.log('‚ùå Showing login message for unauthenticated user');
        form.style.display = 'none';
        loginMessage.style.display = 'block';
      }
    } else {
      console.error('‚ùå Form or login message elements not found');
    }
  }

  async function handleSubmitComment(e) {
    e.preventDefault();
    
    // Check authentication before submitting
    if (!currentUser) {
      const loginRequiredText = translations && translations['comments.loginRequired'] 
        ? translations['comments.loginRequired'] 
        : 'Please login to comment';
      alert(loginRequiredText);
      return;
    }
    
    const formData = new FormData(e.target);
    const content = formData.get('content');

    if (!content) {
      const requiredText = translations && translations['comments.required'] 
        ? translations['comments.required']
        : 'Comment content is required';
      alert(requiredText);
      return;
    }

    // Disable submit button during request
    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    const postingText = translations && translations['comments.posting'] 
      ? translations['comments.posting']
      : 'Posting...';
    submitBtn.disabled = true;
    submitBtn.textContent = postingText;

    try {
      const token = localStorage.getItem('access_token');
      
      // Check if token exists
      if (!token) {
        throw new Error('No authentication token found. Please login again.');
      }
      
      console.log('üîê Token Debug:');
      console.log('Token exists:', !!token);
      console.log('Token length:', token ? token.length : 0);
      console.log('Token preview:', token ? token.substring(0, 20) + '...' : 'null');
      
      // Check if token looks like JWT
      if (token) {
        const parts = token.split('.');
        console.log('Token parts count:', parts.length);
        console.log('Looks like JWT:', parts.length === 3);
        
        // Try to decode JWT header (just for debugging)
        try {
          const header = JSON.parse(atob(parts[0]));
          console.log('JWT Header:', header);
        } catch (e) {
          console.log('Cannot decode JWT header:', e.message);
        }
      }
      
      // Use correct API endpoint from apiUrls
      const url = apiUrls.createPostComment;
      console.log('Creating comment at URL:', url);
      
      const authHeader = `Bearer ${token}`;
      console.log('üîê Authorization header:', authHeader);
      console.log('üîê Authorization header length:', authHeader.length);
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': authHeader
        },
        body: JSON.stringify({
          content: content,
          parent_id: null // For now, no replies
        })
      });

      if (response.ok) {
        // Clear form and reload comments
        e.target.reset();
        loadComments();
        const successText = translations && translations['comments.success'] 
          ? translations['comments.success']
          : 'Comment added successfully';
        showSuccess(successText);
      } else {
        const errorData = await response.json();
        console.error('‚ùå API Error Response:', {
          status: response.status,
          statusText: response.statusText,
          errorData: errorData
        });
        throw new Error(errorData.detail || 'Failed to post comment');
      }
    } catch (error) {
      console.error('Error posting comment:', error);
      const errorText = translations && translations['comments.error'] 
        ? translations['comments.error']
        : 'Error adding comment';
      alert(errorText);
    } finally {
      // Re-enable submit button
      submitBtn.disabled = false;
      submitBtn.textContent = originalText;
    }
  }

  async function loadComments() {
    try {
      console.log('Loading comments for post:', postId);
      // Use correct API endpoint from apiUrls
      const url = apiUrls.getPostComments;
      console.log('API URL:', url);
      
      const response = await fetch(url);
      if (response.ok) {
        const comments = await response.json();
        console.log('Comments loaded successfully:', comments);
        displayComments(comments);
      } else {
        console.error('API response not ok:', response.status, response.statusText);
        throw new Error('Failed to load comments');
      }
    } catch (error) {
      console.error('Error loading comments:', error);
      // Only display error in container, don't show popup
      const container = document.getElementById('comments-list');
      if (container) {
        const errorMessage = translations && translations['comments.error'] 
          ? translations['comments.error'] 
          : 'Error loading comments. Please try again.';
        container.innerHTML = `<p class="text-red-500">${errorMessage}</p>`;
      }
    }
  }

  function displayComments(comments) {
    const container = document.getElementById('comments-list');
    if (!container) {
      console.error('Comments container not found');
      return;
    }

    if (comments.length === 0) {
      const noCommentsText = translations && translations['comments.noComments'] 
        ? translations['comments.noComments'] 
        : 'No comments yet';
      container.innerHTML = `<p class="text-gray-500 italic">${noCommentsText}</p>`;
      return;
    }

    container.innerHTML = comments.map(comment => {
      // Check if current user is the author of this comment
      const isAuthor = currentUser && currentUser.id === comment.user_id;
      
      return `
        <div class="comment border-b border-gray-200 dark:border-gray-700 py-4" data-comment-id="${comment.id}">
          <div class="flex justify-between items-start mb-2">
            <div>
              <strong class="text-gray-900 dark:text-gray-100">${comment.author_name}</strong>
              <span class="text-gray-500 text-sm ml-2">${formatDate(comment.created_at)}</span>
            </div>
            ${isAuthor ? `
              <div class="flex space-x-2">
                <button class="text-blue-600 hover:text-blue-800 text-sm" data-action="edit" data-id="${comment.id}">
                  ${translations && translations['comments.edit'] ? translations['comments.edit'] : 'Edit'}
                </button>
                <button class="text-red-600 hover:text-red-800 text-sm" data-action="delete" data-id="${comment.id}">
                  ${translations && translations['comments.delete'] ? translations['comments.delete'] : 'Delete'}
                </button>
              </div>
            ` : ''}
          </div>
          <div class="text-gray-700 dark:text-gray-300 mb-3 comment-content" data-comment-id="${comment.id}">
            ${comment.content}
          </div>
          <div class="flex items-center space-x-4 text-sm">
            <button class="text-blue-600 hover:text-blue-800" data-action="like" data-id="${comment.id}">
              üëç ${comment.likes_count || 0}
            </button>
            <button class="text-red-600 hover:text-red-800" data-action="dislike" data-id="${comment.id}">
              üëé ${comment.dislikes_count || 0}
            </button>
            <button class="text-gray-600 hover:text-gray-800" data-action="reply" data-id="${comment.id}">
              ${translations && translations['comments.reply'] ? translations['comments.reply'] : 'Reply'}
            </button>
          </div>
        </div>
      `;
    }).join('');
  }

  function handleCommentActions(e) {
    const action = e.target.dataset.action;
    const commentId = e.target.dataset.id;

    if (!action || !commentId) return;

    switch (action) {
      case 'like':
      case 'dislike':
        handleLikeDislike(commentId, action);
        break;
      case 'reply':
        handleReply(commentId);
        break;
      case 'edit':
        handleEdit(commentId);
        break;
      case 'delete':
        handleDelete(commentId);
        break;
    }
  }

  async function handleLikeDislike(commentId, action) {
    try {
      // Check authentication before like/dislike
      if (!currentUser) {
        const loginRequiredText = translations && translations['comments.loginRequired'] 
          ? translations['comments.loginRequired']
          : 'Please login to like/dislike';
        alert(loginRequiredText);
        return;
      }

      const token = localStorage.getItem('access_token');
      
      // Use correct API endpoint from apiUrls
      const url = apiUrls.likeComment(commentId);
      console.log('Like/dislike URL:', url);
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          action: action // 'like' or 'dislike'
        })
      });

      if (response.ok) {
        loadComments(); // Reload to show updated counts
      } else {
        console.error('Failed to update like/dislike');
      }
    } catch (error) {
      console.error('Error updating like/dislike:', error);
    }
  }

  function handleReply(commentId) {
    console.log('Reply to comment:', commentId);
    // Reply functionality to be implemented
  }

  async function handleEdit(commentId) {
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    const contentElement = commentElement.querySelector('.comment-content');
    const currentContent = contentElement.textContent.trim();
    
    // Replace content with textarea for editing
    contentElement.innerHTML = `
      <textarea class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100" rows="3">${currentContent}</textarea>
      <div class="mt-2 space-x-2">
        <button class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-1 rounded text-sm" onclick="saveEdit(${commentId})">Save</button>
        <button class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-1 rounded text-sm" onclick="cancelEdit(${commentId}, '${currentContent.replace(/'/g, "\\'")}')">Cancel</button>
      </div>
    `;
  }

  async function handleDelete(commentId) {
    const confirmText = translations && translations['comments.confirmDelete'] 
      ? translations['comments.confirmDelete']
      : 'Are you sure you want to delete this comment?';
    
    if (!confirm(confirmText)) {
      return;
    }

    try {
      const token = localStorage.getItem('access_token');
      const url = apiUrls.deleteComment(commentId);
      
      const response = await fetch(url, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        loadComments(); // Reload to remove deleted comment
        const successText = translations && translations['comments.deleteSuccess'] 
          ? translations['comments.deleteSuccess']
          : 'Comment deleted successfully';
        showSuccess(successText);
      } else {
        throw new Error('Failed to delete comment');
      }
    } catch (error) {
      console.error('Error deleting comment:', error);
      const errorText = translations && translations['comments.deleteError'] 
        ? translations['comments.deleteError']
        : 'Error deleting comment';
      alert(errorText);
    }
  }

  // Global functions for edit functionality
  window.saveEdit = async function(commentId) {
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    const textarea = commentElement.querySelector('textarea');
    const newContent = textarea.value.trim();
    
    if (!newContent) {
      const requiredText = translations && translations['comments.required'] 
        ? translations['comments.required']
        : 'Comment content is required';
      alert(requiredText);
      return;
    }

    try {
      const token = localStorage.getItem('access_token');
      const url = apiUrls.updateComment(commentId);
      
      const response = await fetch(url, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          content: newContent
        })
      });

      if (response.ok) {
        loadComments(); // Reload to show updated comment
        const successText = translations && translations['comments.editSuccess'] 
          ? translations['comments.editSuccess']
          : 'Comment updated successfully';
        showSuccess(successText);
      } else {
        throw new Error('Failed to update comment');
      }
    } catch (error) {
      console.error('Error updating comment:', error);
      const errorText = translations && translations['comments.editError'] 
        ? translations['comments.editError']
        : 'Error updating comment';
      alert(errorText);
    }
  };

  window.cancelEdit = function(commentId, originalContent) {
    const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
    const contentElement = commentElement.querySelector('.comment-content');
    contentElement.innerHTML = originalContent;
  };

  function formatDate(dateString) {
    const date = new Date(dateString);
    const locale = lang === 'pl' ? 'pl-PL' : 'en-US';
    
    return date.toLocaleDateString(locale, {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }

  function showSuccess(message) {
    // Simple alert for now - can be improved with better UI
    alert(message);
  }
</script>

<section class="comments-section mt-12 border-t border-gray-200 dark:border-gray-700 pt-8">
  <h3 class="text-2xl font-bold text-gray-900 dark:text-gray-100 mb-6">
    {t['comments.title']}
  </h3>

  <!-- Login Required Message -->
  <div id="login-required" class="mb-8 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-6">
    <div class="flex items-center">
      <svg class="w-5 h-5 text-yellow-600 dark:text-yellow-400 mr-3" fill="currentColor" viewBox="0 0 20 20">
        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
      </svg>
      <div>
        <h4 class="text-lg font-medium text-yellow-800 dark:text-yellow-200">
          {lang.toString() === 'pl' ? 'Wymagane logowanie' : 'Login Required'}
        </h4>
        <p class="text-yellow-700 dark:text-yellow-300 mt-1">
          {lang.toString() === 'pl' 
            ? 'Musisz byƒá zalogowany, aby dodaƒá komentarz.' 
            : 'You must be logged in to add a comment.'
          }
        </p>
        <a 
          href={`/${lang}/login`}
          class="inline-block mt-3 bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors"
        >
          {lang.toString() === 'pl' ? 'Zaloguj siƒô' : 'Login'}
        </a>
      </div>
    </div>
  </div>

  <!-- Comment Form (hidden by default, shown when authenticated) -->
  <form id="comment-form" class="mb-8 bg-gray-50 dark:bg-gray-800 p-6 rounded-lg" style="display: none;">
    <h4 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-4">
      {t['comments.addComment']}
    </h4>

    <div class="mb-4">
      <label for="content" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
        {lang.toString() === 'pl' ? 'Komentarz' : 'Comment'}
      </label>
      <textarea
        id="content"
        name="content"
        rows="4"
        required
        class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-100"
        placeholder={t['comments.writeComment']}
      ></textarea>
    </div>

    <button
      type="submit"
      class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-md font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
    >
      {t['comments.submitComment']}
    </button>
  </form>

  <!-- Comments List -->
  <div id="comments-list" class="space-y-4">
    <!-- Comments will be loaded here -->
    <p class="text-gray-500 italic">{t['comments.loading']}</p>
  </div>
</section>
